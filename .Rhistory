# Return blank or placeholder for Opal if no image loaded
list(src = "", alt = "No Image in Opal Mode")
}
}, deleteFile = FALSE)
output$extraction_repro_code <- shiny::renderText({
shiny::req(vals$extracted_params, vals$risk_table_editable)
p <- vals$extracted_params
rt <- vals$risk_table_editable
# --- 3. REPRODUCIBLE CODE WITH FULL VECTORS ---
# Filter empty or null rows for cleaning
rt_clean <- rt %>% dplyr::filter(!is.na(Time))
vec_t <- paste0("c(", paste(rt_clean$Time, collapse=", "), ")")
vec_r1 <- paste0("c(", paste(rt_clean$N_Risk_G1, collapse=", "), ")")
vec_r2 <- paste0("c(", paste(rt_clean$N_Risk_G2, collapse=", "), ")")
paste0(
"library(SurvdigitizeR)\nlibrary(bayescores)\nlibrary(tidyverse)\n\n# INSERT PATH HERE\nimg_path <- 'plot.png'\n\n",
"x_start <- ", p$x_start, "; x_end <- ", p$x_end, "; x_increment <- ", p$x_inc, "\n",
"y_start <- ", p$y_start, "; y_end <- ", p$y_end, "; y_increment <- ", p$y_inc, "\n\n",
"# 1. Digitize\nraw_data <- SurvdigitizeR::survival_digitize(img_path, num_curves=2, x_start=x_start, x_end=x_end, x_increment=x_increment, y_start=y_start, y_end=y_end, y_increment=y_increment, censoring=TRUE)\n",
"if(max(raw_data$St, na.rm=T) > 1.5) raw_data$survival <- raw_data$St/100 else raw_data$survival <- raw_data$St\n\n",
"# 2. Reconstruct IPD (Vectors from Manual Table)\n",
"times <- ", vec_t, "\n",
"n_risk_g1 <- ", vec_r1, "\n",
"n_risk_g2 <- ", vec_r2, "\n\n",
"n_risk_df <- bind_rows(\n",
"  tibble(time_tick = times, nrisk = n_risk_g1, curve = 1),\n",
"  tibble(time_tick = times, nrisk = n_risk_g2, curve = 2)\n",
") %>% filter(!is.na(nrisk))\n\n",
"ipd_list <- list()\n",
"for(cid in 1:2) {\n",
"   km <- subset(raw_data, curve == cid)\n",
"   nr <- subset(n_risk_df, curve == cid)\n",
"   if(nrow(nr) > 0) ipd_list[[cid]] <- bayescores::reconstruct_ipd(km, nr)$ipd %>% mutate(curve=cid)\n",
"}\n",
"final_ipd <- bind_rows(ipd_list) %>% mutate(arm=paste('Group', curve))\n"
)
})
# Updated Plot Output (Dual State)
output$km_plot_output <- shiny::renderPlot({
# State 2: IPD Reconstructed (Final Plot)
if (!is.null(vals$final_ipd) && !is.null(vals$fit_obj)) {
plot_colors <- if(!is.null(vals$curve_colors)) vals$curve_colors else c("#1f77b4", "#ff7f0e")
x_br <- if (!is.null(vals$x_breaks)) vals$x_breaks else waiver()
# If in manual mode, respect original breaks
y_br <- if (!is.null(vals$y_breaks)) vals$y_breaks else waiver()
survminer::ggsurvplot(
vals$fit_obj, data = vals$final_ipd, palette = plot_colors,
pval = TRUE, pval.coord = c(0, 0.1),
risk.table = TRUE, risk.table.col = "strata", risk.table.height = 0.25, risk.table.y.text = FALSE,
break.x.by = if (length(x_br) > 1) diff(x_br)[1] else NULL,
break.y.by = if (length(y_br) > 1) diff(y_br)[1] else NULL,
ggtheme = ggplot2::theme_classic()
)
}
# State 1: Digitized Raw Data (Check Plot)
else if (!is.null(vals$manual_raw_data)) {
# Use raw digitized points from SurvdigitizeR output
ggplot2::ggplot(vals$manual_raw_data, aes(x=time, y=survival, color=as.factor(curve))) +
ggplot2::geom_step(linewidth=1.2) +
ggplot2::theme_minimal() +
ggplot2::labs(title="Digitized Curves Check", subtitle="Review captured curves before applying risk table", y="Survival Probability", x="Time", color="Curve ID") +
ggplot2::theme(legend.position="bottom")
}
})
output$ipd_table_output <- shiny::renderTable({
shiny::req(vals$final_ipd)
head(vals$final_ipd, 20)
})
output$survival_summary_output <- shiny::renderPrint({
shiny::req(vals$cox_obj)
cat("COX MODEL:\n")
print(summary(vals$cox_obj))
cat("\nLOG-RANK:\n")
print(vals$survdiff_obj)
})
output$dl_ipd_excel <- shiny::downloadHandler(
filename = function() "ipd.xlsx",
content = function(f) writexl::write_xlsx(vals$final_ipd, f)
)
output$dl_ipd_rds <- shiny::downloadHandler(
filename = function() "ipd.rds",
content = function(f) saveRDS(vals$final_ipd, f)
)
shiny::observeEvent(input$run_model, {
shiny::req(vals$final_ipd)
shiny::showNotification("Compiling and fitting model...", type = "message", id = "mod_start", duration = NULL)
tryCatch({
hist_arg <- if (input$use_historical) {
paste0("TRUE, params=c(", input$hist_mean, ",", input$hist_sd, ")")
} else {
paste0("FALSE, belief='", input$cure_belief, "'")
}
# Added Density Plots to reproducible code
vals$code_text <- paste0(
"library(bayescores)\nlibrary(rstan)\nipd <- readRDS('path/to/ipd.rds')\n",
"fit <- fit_bayesian_cure_model(ipd, time_col='time', event_col='status', arm_col='arm', iter=",
input$iter, ", chains=", input$chains, ", warmup=", input$warmup, ", shared_shape=",
input$shared_shape, ", use_historical_prior=", hist_arg, ")\n",
"diagnose_fit(fit$stan_fit)\nmodel_diagnostics(fit)\n",
"# Plots\n",
"bayescores::plot_densities(fit)\n",
"bayescores::plot_correlated_densities(fit)"
)
vals$model_fit_obj <- bayescores::fit_bayesian_cure_model(
vals$final_ipd,
time_col = "time", event_col = "status", arm_col = "arm",
iter = input$iter, chains = input$chains, warmup = input$warmup,
seed = seed_val, adapt_delta = adapt_delta_val,
shared_shape = input$shared_shape,
use_historical_prior = input$use_historical,
historical_prior_params = c(input$hist_mean, input$hist_sd),
cure_belief = input$cure_belief
)
shiny::removeNotification(id = "mod_start")
shiny::showNotification("Model fitted!", type = "message")
}, error = function(e) {
shiny::removeNotification(id = "mod_start")
shiny::showNotification(paste("Error:", e$message), type = "error", duration = 10)
})
})
output$model_summary <- shiny::renderPrint({
shiny::req(vals$model_fit_obj)
if (exists("outcomes", asNamespace("bayescores"))) bayescores::outcomes(vals$model_fit_obj) else print(vals$model_fit_obj)
})
output$plot_densities <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
bayescores::plot_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1)
})
output$plot_correlated <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
bayescores::plot_correlated_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1)
})
output$plot_model_fit <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
graphics::par(pty = "s")
plot(vals$model_fit_obj)
})
output$text_diagnostics_table <- shiny::renderPrint({
shiny::req(vals$model_fit_obj)
tryCatch({
if (exists("diagnose_fit", asNamespace("bayescores"))) {
print(bayescores::diagnose_fit(vals$model_fit_obj$stan_fit))
} else {
print(rstan::monitor(vals$model_fit_obj$stan_fit, print = FALSE))
}
}, error = function(e) {
print(rstan::check_hmc_diagnostics(vals$model_fit_obj$stan_fit))
})
})
output$plot_diagnostics <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
tryCatch({
bayescores::model_diagnostics(vals$model_fit_obj)
}, error = function(e) {
plot(vals$model_fit_obj$stan_fit, pars = c("lp__"))
})
})
output$repro_code <- shiny::renderText({
shiny::req(vals$code_text)
vals$code_text
})
output$dl_model_rds <- shiny::downloadHandler(
filename = function() "bayesian_model.rds",
content = function(f) saveRDS(vals$model_fit_obj, f)
)
# NEW: CSV Download for Draws
output$dl_draws_csv <- shiny::downloadHandler(
filename = function() "mcmc_draws.csv",
content = function(f) {
shiny::req(vals$model_fit_obj)
# Extract draws (sims)
# Usually rstan fit objects can be coerced to data.frame
draws <- as.data.frame(vals$model_fit_obj$stan_fit)
write.csv(draws, f, row.names = FALSE)
}
)
output$dl_plot_dens <- shiny::downloadHandler(
filename = "densities.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
# Capture the plot object first to avoid auto-printing if any
p <- bayescores::plot_densities(vals$model_fit_obj)
# Add theme and print explicitly
print(p + ggplot2::theme(aspect.ratio = 1))
dev.off()
}
)
output$dl_plot_corr <- shiny::downloadHandler(
filename = "correlated.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
print(bayescores::plot_correlated_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1))
dev.off()
}
)
output$dl_plot_fit <- shiny::downloadHandler(
filename = "fit.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
graphics::par(pty = "s")
plot(vals$model_fit_obj)
dev.off()
}
)
output$dl_plot_diag <- shiny::downloadHandler(
filename = "diagnostics.pdf",
content = function(f) {
shiny::req(vals$model_fit_obj)
pdf(f, width = 10, height = 8)
tryCatch({
bayescores::model_diagnostics(vals$model_fit_obj)
}, error = function(e) {
plot(vals$model_fit_obj$stan_fit, pars = c("lp__"))
})
dev.off()
}
)
}
shiny::shinyApp(ui, server)
}
# Add globalVariables to avoid R CMD check notes about non-standard evaluation
utils::globalVariables(c("Time", "N_Risk_G1", "N_Risk_G2", "time_tick", "nrisk", "time", "survival", "curve", "status", "arm", "cluster", "dataTableOutput", "renderDataTable"))
km2bayes()
library(survival)
library(flexsurv)
library(flexsurvcure)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(splines)
library(ggeffects)
# ==============================================================================
# 1. HELPER: CÁLCULO DE RMST (Tu código adaptado a función)
# ==============================================================================
get_rmst_metrics <- function(data, time_col="time", status_col="event", arm_col="arm") {
# Preparar datos
df <- data
df$time_v <- df[[time_col]]
df$status_v <- df[[status_col]]
df$trt_v <- df[[arm_col]]
# Ajustar modelos KM
fit1 <- survfit(Surv(time_v, status_v) ~ 1, data = subset(df, trt_v == "Control"))
fit2 <- survfit(Surv(time_v, status_v) ~ 1, data = subset(df, trt_v == "Experimental"))
# Encontrar Tau Común (Mínimo de los máximos)
max_t1 <- max(df$time_v[df$trt_v == "Control"])
max_t2 <- max(df$time_v[df$trt_v == "Experimental"])
tau_comun <- min(max_t1, max_t2)
# Extraer RMST
# Usamos tryCatch por seguridad si los tiempos son muy cortos
res <- tryCatch({
rmst1 <- summary(fit1, rmean = tau_comun)$table
rmst2 <- summary(fit2, rmean = tau_comun)$table
# Valores
val1 <- rmst1["rmean"]
val2 <- rmst2["rmean"]
se1  <- rmst1["se(rmean)"]
se2  <- rmst2["se(rmean)"]
# Diferencia (Exp - Control para que positivo sea bueno)
diff_rmst <- val2 - val1
se_diff <- sqrt(se1^2 + se2^2)
# Estadísticos
z_score <- diff_rmst / se_diff
p_val <- 2 * pnorm(-abs(z_score))
list(
rmst_ctrl = val1, rmst_exp = val2,
diff_rmst = diff_rmst, se_diff = se_diff,
pval_rmst = p_val, tau = tau_comun
)
}, error = function(e) {
return(list(rmst_ctrl=NA, rmst_exp=NA, diff_rmst=NA, se_diff=NA, pval_rmst=NA, tau=NA))
})
return(res)
}
# ==============================================================================
# 2. GENERADOR NPH (Lógica Piecewise)
# ==============================================================================
simulate_nph_trial <- function(n, lambda_c, hr_early, hr_late, t_change, max_fu) {
rpwe <- function(n, r1, r2, tc) {
u <- runif(n); t <- numeric(n)
p_change <- 1 - exp(-r1 * tc)
idx_e <- which(u > (1 - p_change)); idx_l <- which(u <= (1 - p_change))
if(length(idx_e)>0) t[idx_e] <- -log(u[idx_e]) / r1
if(length(idx_l)>0) t[idx_l] <- tc + (-log(u[idx_l]/(1-p_change)) / r2)
return(t)
}
arm <- sample(c("Control", "Experimental"), n, replace = TRUE)
t_lat <- numeric(n)
idx_c <- which(arm == "Control"); if(length(idx_c)>0) t_lat[idx_c] <- rexp(length(idx_c), lambda_c)
idx_e <- which(arm == "Experimental"); if(length(idx_e)>0) t_lat[idx_e] <- rpwe(length(idx_e), lambda_c*hr_early, lambda_c*hr_late, t_change)
df <- data.frame(id=1:n, arm=factor(arm, levels=c("Control", "Experimental")), time=pmin(t_lat, max_fu), event=as.numeric(t_lat <= max_fu))
return(df)
}
# Helper Pearson
get_pearson_flex <- function(data) {
tryCatch({
sf <- median(data$time)
data$ts <- data$time / sf
fit <- flexsurvcure(Surv(ts, event)~arm, data=data, anc=list(scale=~arm), dist="weibull", mixture=T, method="Nelder-Mead", control=list(maxit=5000))
vc <- vcov(fit)
idx_th <- which(rownames(vc)=="armExperimental")
idx_sc <- grep("scale\\(armExperimental\\)", rownames(vc))
if(length(idx_th)>0 & length(idx_sc)>0) return(vc[idx_th, idx_sc]/(sqrt(vc[idx_th, idx_th])*sqrt(vc[idx_sc, idx_sc])))
return(NA)
}, error=function(e) NA)
}
# ==============================================================================
# 3. SIMULACIÓN MASIVA (Guardando todo)
# ==============================================================================
target_n <- 500
results_list <- list()
valid_count <- 0
iter_total <- 0
cat("Generando simulación (Solo Éxito vs Dilución)... \n")
while(valid_count < target_n) {
iter_total <- iter_total + 1
if(iter_total %% 50 == 0) cat(sprintf("\r[%d] -> %d Válidos", iter_total, valid_count))
# A. Escenarios (SIN CRUCE)
N_size <- round(runif(1, 400, 800))
med_ctrl <- runif(1, 12, 18); lambda_c <- log(2)/med_ctrl
# HR Early: Siempre bueno (0.5 - 0.7)
hr_early <- runif(1, 0.5, 0.7)
# DECISIÓN DEL ESCENARIO
tipo_escenario <- sample(c("EXITO", "DILUCION"), 1)
if(tipo_escenario == "EXITO") {
# Caso 1: El efecto se mantiene (Sostenido)
hr_late <- hr_early
} else {
# Caso 2: El efecto se pierde (Dilución), pero NO cruza brutalmente (1.0 - 1.1)
hr_late <- runif(1, 0.95, 1.15)
}
t_change <- med_ctrl * runif(1, 0.8, 1.2) # El cambio ocurre cerca de la mediana
# B. Generar Datos
df_long <- simulate_nph_trial(N_size, lambda_c, hr_early, hr_late, t_change, med_ctrl*5)
cutoff_time <- med_ctrl * runif(1, 1.0, 1.5)
df_short <- df_long
df_short$event <- ifelse(df_short$time > cutoff_time, 0, df_short$event)
df_short$time <- pmin(df_short$time, cutoff_time)
# C. FILTRO: Positivo al inicio
cox_s <- coxph(Surv(time, event)~arm, data=df_short)
if(summary(cox_s)$coef[5] >= 0.05 || summary(cox_s)$coef[2] > 0.9) next
# D. Cálculos Completos
pears <- get_pearson_flex(df_short)
if(is.na(pears)) next
# Métricas Cox
res_cox_l <- summary(coxph(Surv(time, event)~arm, data=df_long))
# Métricas RMST (Usando tu función)
rmst_s <- get_rmst_metrics(df_short)
rmst_l <- get_rmst_metrics(df_long)
if(is.na(rmst_s$diff_rmst) || is.na(rmst_l$diff_rmst)) next
valid_count <- valid_count + 1
censura <- 1 - sum(df_short$event)/N_size
# E. GUARDAR TODO
results_list[[valid_count]] <- data.frame(
Escenario = tipo_escenario,
Pearson_Initial = abs(pears),
Inmadurez_Censura = censura,
N_Total = N_size,
# Datos Cox
HR_Short = summary(cox_s)$coef[2],
HR_Long = res_cox_l$coef[2],
Diff_HR = res_cox_l$coef[2] - summary(cox_s)$coef[2], # Deterioro HR
# Datos RMST (Short)
RMST_Diff_Short = rmst_s$diff_rmst,
RMST_Pval_Short = rmst_s$pval_rmst,
RMST_Tau_Short  = rmst_s$tau,
# Datos RMST (Long)
RMST_Diff_Long = rmst_l$diff_rmst,
RMST_Pval_Long = rmst_l$pval_rmst,
RMST_Tau_Long  = rmst_l$tau,
# Diferencia de RMST (Lo que perdimos vs lo esperado)
# Si Short=5 meses ganados y Long=2 meses ganados -> Deterioro de -3
Deterioro_RMST = rmst_l$diff_rmst - rmst_s$diff_rmst
)
}
df_final <- do.call(rbind, results_list)
# ==============================================================================
# 4. PLOTS ELEGANTES (SIN IC, ESTILO PAPER)
# ==============================================================================
# Definir paleta elegante
cols_escenario <- c("EXITO" = "#2C3E50", "DILUCION" = "#E74C3C")
# Modelo para las líneas suaves
mod_hr <- lm(Diff_HR ~ ns(Pearson_Initial, 3), data=df_final)
mod_rmst <- lm(RMST_Diff_Long ~ ns(Pearson_Initial, 3), data=df_final)
# Grid para líneas limpias
grid_viz <- data.frame(Pearson_Initial = seq(0, 1, length.out=300))
grid_viz$Pred_HR <- predict(mod_hr, newdata=grid_viz)
grid_viz$Pred_RMST <- predict(mod_rmst, newdata=grid_viz)
# TEMA BASE LIMPIO
theme_elegante <- theme_classic() +
theme(
text = element_text(family = "sans", color = "#2c3e50"),
plot.title = element_text(face = "bold", size = 14, hjust = 0),
plot.subtitle = element_text(size = 11, color = "gray40"),
axis.title = element_text(face = "bold", size = 10),
legend.position = "top",
panel.grid.major.y = element_line(color = "gray90", size = 0.3)
)
# PLOT 1: DETERIORO DEL HR
# Eje Y: Cuánto empeora el HR (Long - Short)
# Puntos coloreados por escenario real
p1 <- ggplot() +
# Puntos crudos (alpha bajo)
geom_point(data = df_final, aes(x = Pearson_Initial, y = Diff_HR, color = Escenario),
alpha = 0.4, size = 1.5) +
# Línea de tendencia global (Negra, elegante, sin IC)
geom_line(data = grid_viz, aes(x = Pearson_Initial, y = Pred_HR),
color = "black", size = 1.2) +
scale_color_manual(values = cols_escenario) +
labs(
title = "A. Predicción del Deterioro del Hazard Ratio",
subtitle = "Diferencia: HR Final (Maduro) - HR Inicial. Valores altos indican pérdida de eficacia.",
x = "Correlación Pearson (Datos Inmaduros)",
y = "Deterioro del HR (+)"
) +
theme_elegante
# PLOT 2: BENEFICIO FINAL EN RMST (Vida Ganada Real)
# Eje Y: RMST Difference Final (Meses ganados al final)
p2 <- ggplot() +
# Puntos
geom_point(data = df_final, aes(x = Pearson_Initial, y = RMST_Diff_Long, color = Escenario),
alpha = 0.4, size = 1.5) +
# Línea de tendencia
geom_line(data = grid_viz, aes(x = Pearson_Initial, y = Pred_RMST),
color = "black", size = 1.2) +
scale_color_manual(values = cols_escenario) +
labs(
title = "B. Beneficio Final Confirmado (RMST)",
subtitle = "Meses de vida ganados al final del seguimiento (Long Term).",
x = "Correlación Pearson (Datos Inmaduros)",
y = "Diferencia RMST Final (Meses)"
) +
theme_elegante
# PLOT 3: DISTRIBUCIÓN DE ESCENARIOS
# Muestra cómo el Pearson separa los puntos rojos (Dilución) de los azules (Éxito)
p3 <- ggplot(df_final, aes(x = Pearson_Initial, fill = Escenario)) +
geom_density(alpha = 0.7, color = NA) +
scale_fill_manual(values = cols_escenario) +
labs(
title = "C. Densidad de Pearson por Escenario",
subtitle = "¿Es el Pearson capaz de distinguir Éxito vs Dilución?",
x = "Correlación Pearson",
y = "Densidad"
) +
theme_elegante + theme(axis.line.y = element_blank(), axis.text.y = element_blank())
# Layout final
grid.arrange(p1, p2, p3, layout_matrix = rbind(c(1,1), c(2,2), c(3,3)))
# ==============================================================================
# 5. AÑADIDO: PLOT DE PROBABILIDAD DE FALLO (DILUCIÓN)
# ==============================================================================
# 1. Ajuste del Modelo Logístico (Binario)
# Definimos "Fallo" como ser del escenario DILUCION (1) vs EXITO (0)
df_final$Es_Fallo <- ifelse(df_final$Escenario == "DILUCION", 1, 0)
mod_prob <- glm(Es_Fallo ~ ns(Pearson_Initial, 3), family = binomial, data = df_final)
# 2. Predicción sobre el Grid existente
# type="response" nos da la probabilidad (0 a 1)
grid_viz$Prob_Fallo <- predict(mod_prob, newdata = grid_viz, type = "response")
# 3. Creación del Plot D (Estilo Elegante)
p4 <- ggplot() +
# Usamos un área suave o línea gruesa para indicar riesgo
geom_line(data = grid_viz, aes(x = Pearson_Initial, y = Prob_Fallo),
color = "#E74C3C", size = 1.5) + # Color Rojo del escenario Dilución
# Línea de referencia del 50%
geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray60") +
annotate("text", x = 0, y = 0.52, label = "Umbral aleatorio (50%)",
hjust = 0, size = 3, color = "gray60", family = "sans") +
scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
labs(
title = "D. Probabilidad de Fallo Final (Dilución)",
subtitle = "Probabilidad estimada de que el beneficio inicial se diluya.",
x = "Correlación Pearson (Datos Inmaduros)",
y = "Probabilidad de Escenario 'Dilución'"
) +
theme_elegante
# ==============================================================================
# 6. LAYOUT FINAL (2x2)
# ==============================================================================
grid.arrange(p1, p2, p3, p4, ncol = 2)
df_final
library(splines)
# ==============================================================================
# MODELOS MULTIVARIABLES (Con Ajuste por Censura y Tamaño Muestral)
# ==============================================================================
# 1. Modelo para el Deterioro del HR (Diff_HR)
# ¿Predice el Pearson cuánto va a empeorar el HR?
mod_hr_multi <- lm(Diff_HR ~ ns(Pearson_Initial, df=3) * Inmadurez_Censura + N_Total,
data = df_final)
# 2. Modelo para el Beneficio RMST Final (RMST_Diff_Long)
# ¿Predice el Pearson cuánta vida real se ganará al final?
mod_rmst_multi <- lm(RMST_Diff_Long ~ ns(Pearson_Initial, df=3) * Inmadurez_Censura + N_Total,
data = df_final)
# 3. Modelo para Probabilidad de Fallo (Escenario Dilución)
# ¿Predice el Pearson la probabilidad de ser un escenario de Dilución?
mod_prob_multi <- glm(Es_Fallo ~ ns(Pearson_Initial, df=3) * Inmadurez_Censura + N_Total,
family = binomial, data = df_final)
# ==============================================================================
# RESULTADOS Y TABLAS ANOVA
# ==============================================================================
cat("\n=== 1. ANOVA: DETERIORO DEL HAZARD RATIO (Diff_HR) ===\n")
print(anova(mod_hr_multi))
cat("\n--- Resumen Coeficientes ---\n")
print(summary(mod_hr_multi)$coefficients)
cat("\n======================================================\n")
cat("\n=== 2. ANOVA: BENEFICIO RMST FINAL (Vida Ganada) ===\n")
print(anova(mod_rmst_multi))
cat("\n--- Resumen Coeficientes ---\n")
print(summary(mod_rmst_multi)$coefficients)
cat("\n======================================================\n")
cat("\n=== 3. ANOVA: PROBABILIDAD DE DILUCIÓN (Logístico) ===\n")
# Usamos test Chisq para modelos GLM
print(anova(mod_prob_multi, test = "Chisq"))
cat("\n--- Resumen Coeficientes ---\n")
print(summary(mod_prob_multi)$coefficients)
