# ==============================================================================
server <- function(input, output, session) {
seed_val <- 555; adapt_delta_val <- 0.99
temp_dir <- tempdir()
addResourcePath("temp_img", temp_dir)
vals <- shiny::reactiveValues(
final_ipd = NULL, fit_obj = NULL, cox_obj = NULL, survdiff_obj = NULL, model_fit_obj = NULL,
code_text = NULL, extraction_code = NULL, debug_data = NULL, original_img_path = NULL,
processed_img_path = NULL, # Path for image with magick adjustments
curve_colors = NULL, x_breaks = NULL, y_breaks = NULL,
risk_table_editable = NULL, y_axis_editable = NULL, extracted_params = NULL,
manual_raw_data = NULL, # New: saves manual digitization
mode = "manual"
)
# --- STOP: DO NOT TOUCH PYTHON / RETICULATE ---
shiny::onStop(function() {
cat("App stopped.\n")
})
# 1. Load image and set initial path
shiny::observeEvent(input$img_upload, {
shiny::req(input$img_upload)
vals$original_img_path <- input$img_upload$datapath
vals$processed_img_path <- input$img_upload$datapath
})
# 2. Observer to apply Magick in real time (Brightness, Contrast, Border)
shiny::observe({
shiny::req(vals$original_img_path)
# Trigger with any visual change or new image
input$man_border
input$man_brightness
input$man_contrast
tryCatch({
img <- magick::image_read(vals$original_img_path)
# Apply border if > 0
if(!is.null(input$man_border) && input$man_border > 0) {
geom <- paste0(input$man_border, "x", input$man_border)
img <- magick::image_border(img, "white", geom)
}
# Apply brightness/contrast
if(!is.null(input$man_brightness) && !is.null(input$man_contrast)) {
img <- magick::image_modulate(img, brightness = input$man_brightness, saturation = 100, hue = 100)
img <- magick::image_contrast(img, sharpen = (input$man_contrast - 100)/50) # Approx mapping
}
# Save temporarily
tmp_proc <- file.path(temp_dir, paste0("proc_view_", as.integer(Sys.time()), ".png"))
magick::image_write(img, tmp_proc, format = "png")
vals$processed_img_path <- tmp_proc
}, error = function(e){
warning("Magick processing failed")
})
})
# --- RESET ALL (START OVER): reliable hard reset ---
shiny::observeEvent(input$reset_all, {
# Reset reactive values manually to ensure clean state for new image
vals$final_ipd <- NULL
vals$fit_obj <- NULL
vals$cox_obj <- NULL
vals$survdiff_obj <- NULL
vals$model_fit_obj <- NULL
vals$code_text <- NULL
vals$extraction_code <- NULL
vals$debug_data <- NULL
vals$original_img_path <- NULL
vals$processed_img_path <- NULL
vals$curve_colors <- NULL
vals$x_breaks <- NULL
vals$y_breaks <- NULL
vals$risk_table_editable <- NULL
vals$y_axis_editable <- NULL
vals$extracted_params <- NULL
vals$manual_raw_data <- NULL
vals$mode <- "manual"
session$reload()
})
# ==============================================================================
# MANUAL MODE: Click & Digitize with SurvdigitizeR (Main Thread)
# ==============================================================================
shiny::observeEvent(input$run_manual_dig, {
# FIX: Ensure processed_img_path is refreshed if inputs changed but observe hasn't fired yet
shiny::req(vals$original_img_path)
# Force refresh of processed image
img <- magick::image_read(vals$original_img_path)
if(!is.null(input$man_border) && input$man_border > 0) {
geom <- paste0(input$man_border, "x", input$man_border)
img <- magick::image_border(img, "white", geom)
}
if(!is.null(input$man_brightness) && !is.null(input$man_contrast)) {
img <- magick::image_modulate(img, brightness = input$man_brightness, saturation = 100, hue = 100)
img <- magick::image_contrast(img, sharpen = (input$man_contrast - 100)/50)
}
tmp_proc <- file.path(temp_dir, paste0("proc_view_run_", as.integer(Sys.time()), ".png"))
magick::image_write(img, tmp_proc, format = "png")
vals$processed_img_path <- tmp_proc
vals$mode <- "manual"
shiny::showNotification("Starting Manual Digitization. Check for popup window...", type = "message", duration = 5)
# Generate time sequence for empty table
t_start <- input$man_x_start
t_end <- input$man_x_end
t_inc <- input$man_x_inc
if(is.na(t_inc) || t_inc <= 0) t_inc <- (t_end - t_start)/5
vec_times <- seq(t_start, t_end, by = t_inc)
# Create empty table (Grid) - NAMES IN ENGLISH
empty_risk <- tibble::tibble(
Time = as.numeric(vec_times),
N_Risk_G1 = rep(NA_real_, length(vec_times)),
N_Risk_G2 = rep(NA_real_, length(vec_times))
)
vals$risk_table_editable <- empty_risk
# FIX: Y values without multiplying by 100
y_seq <- seq(input$man_y_start, input$man_y_end, by=input$man_y_inc)
vals$y_axis_editable <- data.frame(Y_Values = y_seq)
# Save manual parameters
vals$extracted_params <- list(
x_start = input$man_x_start, x_end = input$man_x_end, x_inc = input$man_x_inc,
y_start = input$man_y_start, y_end = input$man_y_end, y_inc = input$man_y_inc
)
# Run survival_digitize with manual arguments (WITHOUT attempt_OCR)
# Use vals$processed_img_path to include added borders/brightness
tryCatch({
raw <- SurvdigitizeR::survival_digitize(
img_path = vals$processed_img_path,
bg_lightness = input$man_bg_light,
attempt_OCR = FALSE, # Explicitly FALSE or omitted
word_sensitivity = input$man_word_sens,
num_curves = input$man_num_curves,
censoring = input$man_censoring,
x_start = input$man_x_start,
x_end = input$man_x_end,
x_increment = input$man_x_inc,
y_start = input$man_y_start,
y_end = input$man_y_end,
y_increment = input$man_y_inc,
y_text_vertical = input$man_y_vert,
nr_neighbors = input$man_neighbors,
enhance = input$man_enhance,
impute_size = input$man_impute,
line_censoring = input$man_line_cens
)
# Adjust Y scale if necessary (SurvdigitizeR sometimes returns 0-100)
if (max(raw$St, na.rm = TRUE) > 1.5) raw$survival <- raw$St / 100 else raw$survival <- raw$St
vals$manual_raw_data <- raw
vals$debug_data <- list(manual = TRUE, params = vals$extracted_params)
shiny::showNotification("Digitization complete! Fill Risk Table and click 'Generate IPD'.", type = "warning", duration = 10)
}, error = function(e) {
shiny::showNotification(paste("Error in manual digitization:", e$message), type = "error")
})
})
# Render Editables - FIX: stretchH to avoid row cutting
output$hot_risk_table <- rhandsontable::renderRHandsontable({
shiny::req(vals$risk_table_editable)
# Increase height for better visibility and working scroll
rhandsontable::rhandsontable(vals$risk_table_editable, stretchH = "all", height = 450) %>%
rhandsontable::hot_context_menu(allowRowEdit = TRUE, allowColEdit = FALSE) %>%
rhandsontable::hot_cols(colWidths = 100)
})
output$hot_y_axis <- rhandsontable::renderRHandsontable({
shiny::req(vals$y_axis_editable)
# Reduce height of Y-axis table
rhandsontable::rhandsontable(vals$y_axis_editable, stretchH = "all", height = 150) %>%
rhandsontable::hot_context_menu(allowRowEdit = TRUE, allowColEdit = FALSE)
})
# Apply Edits - CENTRAL CALCULATION BUTTON
shiny::observeEvent(input$apply_edits, {
# We need the table and a loaded image
shiny::req(input$hot_risk_table, vals$original_img_path)
new_risk <- rhandsontable::hot_to_r(input$hot_risk_table)
new_y_df <- rhandsontable::hot_to_r(input$hot_y_axis)
new_y <- as.numeric(new_y_df$Y_Values)
vals$risk_table_editable <- new_risk
vals$y_axis_editable <- new_y_df
shiny::showNotification("Re-calculating IPD...", type = "message", id = "ext_recalc", duration = NULL)
if (vals$mode == "manual") {
# Logic for MANUAL MODE:
# 1. Retrieve raw digitization (vals$manual_raw_data)
# 2. Use manual table (new_risk)
# 3. Reconstruct
tryCatch({
if(is.null(vals$manual_raw_data)) stop("No manual digitization found. Run Manual Digitization first.")
# Update breaks for plot
vals$x_breaks <- new_risk$Time
vals$y_breaks <- new_y
reconstruir_ipd_manual(vals$manual_raw_data, new_risk)
shiny::removeNotification(id = "ext_recalc")
shiny::showNotification("IPD Reconstructed from Manual Input", type = "message")
}, error = function(e){
shiny::removeNotification(id = "ext_recalc")
shiny::showNotification(paste("Error rebuilding:", e$message), type = "error")
})
}
})
# ==============================================================================
# Core Logic: FINAL RECONSTRUCTION (Shared / Manual)
# ==============================================================================
# Helper function to convert table and raw data into IPD (Final part of the process)
reconstruir_ipd_manual <- function(raw_data, tabla_riesgo) {
limpiar <- function(x) as.numeric(gsub("[^0-9.]", "", as.character(x)))
# --- 1. MONOTONICITY CHECK (NRISK CANNOT INCREASE) ---
check_mono <- function(x) {
x_clean <- as.numeric(x[!is.na(x)])
if(length(x_clean) < 2) return(TRUE)
# diff(x) must be <= 0 (decreasing or equal). If any diff > 0, error.
if(any(diff(x_clean) > 0)) return(FALSE)
return(TRUE)
}
if(!check_mono(tabla_riesgo$N_Risk_G1)) stop("Error: N_Risk_G1 increases over time. Numbers at risk must be monotonically decreasing.")
if(!check_mono(tabla_riesgo$N_Risk_G2)) stop("Error: N_Risk_G2 increases over time. Numbers at risk must be monotonically decreasing.")
# Use of ENGLISH names
df_c1 <- tabla_riesgo %>%
dplyr::transmute(time_tick = as.numeric(Time), nrisk = limpiar(N_Risk_G1), curve = 1) %>%
dplyr::filter(!is.na(time_tick), !is.na(nrisk))
df_c2 <- tabla_riesgo %>%
dplyr::transmute(time_tick = as.numeric(Time), nrisk = limpiar(N_Risk_G2), curve = 2) %>%
dplyr::filter(!is.na(time_tick), !is.na(nrisk))
nrisk_all <- dplyr::bind_rows(df_c1, df_c2)
ipd_list <- list()
for (cid in unique(nrisk_all$curve)) {
km <- subset(raw_data, curve == cid)
nr <- subset(nrisk_all, curve == cid)
if (nrow(nr) >= 2 && nrow(km) > 0) {
ipd_list[[cid]] <- bayescores::reconstruct_ipd(km, nr)$ipd %>% dplyr::mutate(curve = cid)
}
}
if (length(ipd_list) > 0) {
final <- dplyr::bind_rows(ipd_list) %>% dplyr::mutate(arm = paste("Group", curve))
# Initial model fit to check direction
mod_init <- coxph(Surv(time, status) ~ arm, final)
# --- 2. AUTOMATIC ARM SWITCH IF COEF > 0 ---
# If coef is positive, it means the reference group is 'better' than the other (HR > 1).
# Invert labels to force HR < 1 (negative coef).
coef_val <- tryCatch(coef(mod_init)[1], error=function(e) 0)
if(!is.na(coef_val) && coef_val > 0) {
final$arm <- ifelse(final$arm == "Group 1", "TEMP", "Group 1")
final$arm <- ifelse(final$arm == "TEMP", "Group 2", final$arm)
# Re-adjust objects with new arm
mod_init <- coxph(Surv(time, status) ~ arm, final)
shiny::showNotification("Arms switched automatically (positive coefficient detected).", type="warning", duration=5)
}
vals$final_ipd <- final
vals$fit_obj <- survfit(Surv(time, status) ~ arm, final)
vals$cox_obj <- mod_init
vals$survdiff_obj <- survdiff(Surv(time, status) ~ arm, final)
# Default colors
vals$curve_colors <- c("#1f77b4", "#ff7f0e")
} else {
stop("Could not reconstruct curves. Check Risk Table data.")
}
}
# --------------------------------------------------------------------------
# OUTPUTS
# --------------------------------------------------------------------------
output$original_image_output <- shiny::renderImage({
shiny::req(vals$processed_img_path)
list(src = vals$processed_img_path, height = "100%", width = "auto", alt = "Orig")
}, deleteFile = FALSE)
output$extraction_repro_code <- shiny::renderText({
shiny::req(vals$extracted_params, vals$risk_table_editable)
p <- vals$extracted_params
rt <- vals$risk_table_editable
# --- 3. REPRODUCIBLE CODE WITH FULL VECTORS ---
# Filter empty or null rows for cleaning
rt_clean <- rt %>% dplyr::filter(!is.na(Time))
vec_t <- paste0("c(", paste(rt_clean$Time, collapse=", "), ")")
vec_r1 <- paste0("c(", paste(rt_clean$N_Risk_G1, collapse=", "), ")")
vec_r2 <- paste0("c(", paste(rt_clean$N_Risk_G2, collapse=", "), ")")
paste0(
"library(SurvdigitizeR)\nlibrary(bayescores)\nlibrary(tidyverse)\n\n# INSERT PATH HERE\nimg_path <- 'plot.png'\n\n",
"x_start <- ", p$x_start, "; x_end <- ", p$x_end, "; x_increment <- ", p$x_inc, "\n",
"y_start <- ", p$y_start, "; y_end <- ", p$y_end, "; y_increment <- ", p$y_inc, "\n\n",
"# 1. Digitize\nraw_data <- SurvdigitizeR::survival_digitize(img_path, num_curves=2, x_start=x_start, x_end=x_end, x_increment=x_increment, y_start=y_start, y_end=y_end, y_increment=y_increment, censoring=TRUE)\n",
"if(max(raw_data$St, na.rm=T) > 1.5) raw_data$survival <- raw_data$St/100 else raw_data$survival <- raw_data$St\n\n",
"# 2. Reconstruct IPD (Vectors from Manual Table)\n",
"times <- ", vec_t, "\n",
"n_risk_g1 <- ", vec_r1, "\n",
"n_risk_g2 <- ", vec_r2, "\n\n",
"n_risk_df <- bind_rows(\n",
"  tibble(time_tick = times, nrisk = n_risk_g1, curve = 1),\n",
"  tibble(time_tick = times, nrisk = n_risk_g2, curve = 2)\n",
") %>% filter(!is.na(nrisk))\n\n",
"ipd_list <- list()\n",
"for(cid in 1:2) {\n",
"   km <- subset(raw_data, curve == cid)\n",
"   nr <- subset(n_risk_df, curve == cid)\n",
"   if(nrow(nr) > 0) ipd_list[[cid]] <- bayescores::reconstruct_ipd(km, nr)$ipd %>% mutate(curve=cid)\n",
"}\n",
"final_ipd <- bind_rows(ipd_list) %>% mutate(arm=paste('Group', curve))\n"
)
})
# Updated Plot Output (Dual State)
output$km_plot_output <- shiny::renderPlot({
# State 2: IPD Reconstructed (Final Plot)
if (!is.null(vals$final_ipd) && !is.null(vals$fit_obj)) {
plot_colors <- if(!is.null(vals$curve_colors)) vals$curve_colors else c("#1f77b4", "#ff7f0e")
x_br <- if (!is.null(vals$x_breaks)) vals$x_breaks else waiver()
# If in manual mode, respect original breaks
y_br <- if (!is.null(vals$y_breaks) && vals$mode == "manual") vals$y_breaks else waiver()
survminer::ggsurvplot(
vals$fit_obj, data = vals$final_ipd, palette = plot_colors,
pval = TRUE, pval.coord = c(0, 0.1),
risk.table = TRUE, risk.table.col = "strata", risk.table.height = 0.25, risk.table.y.text = FALSE,
break.x.by = if (length(x_br) > 1) diff(x_br)[1] else NULL,
break.y.by = if (length(y_br) > 1) diff(y_br)[1] else NULL,
ggtheme = survminer::theme_classic()
)
}
# State 1: Digitized Raw Data (Check Plot)
else if (!is.null(vals$manual_raw_data)) {
# Use raw digitized points from SurvdigitizeR output
ggplot2::ggplot(vals$manual_raw_data, aes(x=time, y=survival, color=as.factor(curve))) +
ggplot2::geom_step(linewidth=1.2) +
ggplot2::theme_minimal() +
ggplot2::labs(title="Digitized Curves Check", subtitle="Review captured curves before applying risk table", y="Survival Probability", x="Time", color="Curve ID") +
ggplot2::theme(legend.position="bottom")
}
})
output$ipd_table_output <- shiny::renderTable({
shiny::req(vals$final_ipd)
head(vals$final_ipd, 20)
})
output$survival_summary_output <- shiny::renderPrint({
shiny::req(vals$cox_obj)
cat("COX MODEL:\n")
print(summary(vals$cox_obj))
cat("\nLOG-RANK:\n")
print(vals$survdiff_obj)
})
output$dl_ipd_excel <- shiny::downloadHandler(
filename = function() "ipd.xlsx",
content = function(f) writexl::write_xlsx(vals$final_ipd, f)
)
output$dl_ipd_rds <- shiny::downloadHandler(
filename = function() "ipd.rds",
content = function(f) saveRDS(vals$final_ipd, f)
)
shiny::observeEvent(input$run_model, {
shiny::req(vals$final_ipd)
shiny::showNotification("Compiling and fitting model...", type = "message", id = "mod_start", duration = NULL)
tryCatch({
hist_arg <- if (input$use_historical) {
paste0("TRUE, params=c(", input$hist_mean, ",", input$hist_sd, ")")
} else {
paste0("FALSE, belief='", input$cure_belief, "'")
}
# Added Density Plots to reproducible code
vals$code_text <- paste0(
"library(bayescores)\nlibrary(rstan)\nipd <- readRDS('path/to/ipd.rds')\n",
"fit <- fit_bayesian_cure_model(ipd, time_col='time', event_col='status', arm_col='arm', iter=",
input$iter, ", chains=", input$chains, ", warmup=", input$warmup, ", shared_shape=",
input$shared_shape, ", use_historical_prior=", hist_arg, ")\n",
"diagnose_fit(fit$stan_fit)\nmodel_diagnostics(fit)\n",
"# Plots\n",
"bayescores::plot_densities(fit)\n",
"bayescores::plot_correlated_densities(fit)"
)
vals$model_fit_obj <- bayescores::fit_bayesian_cure_model(
vals$final_ipd,
time_col = "time", event_col = "status", arm_col = "arm",
iter = input$iter, chains = input$chains, warmup = input$warmup,
seed = seed_val, adapt_delta = adapt_delta_val,
shared_shape = input$shared_shape,
use_historical_prior = input$use_historical,
historical_prior_params = c(input$hist_mean, input$hist_sd),
cure_belief = input$cure_belief
)
shiny::removeNotification(id = "mod_start")
shiny::showNotification("Model fitted!", type = "message")
}, error = function(e) {
shiny::removeNotification(id = "mod_start")
shiny::showNotification(paste("Error:", e$message), type = "error", duration = 10)
})
})
output$model_summary <- shiny::renderPrint({
shiny::req(vals$model_fit_obj)
if (exists("outcomes", asNamespace("bayescores"))) bayescores::outcomes(vals$model_fit_obj) else print(vals$model_fit_obj)
})
output$plot_densities <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
bayescores::plot_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1)
})
output$plot_correlated <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
bayescores::plot_correlated_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1)
})
output$plot_model_fit <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
graphics::par(pty = "s")
plot(vals$model_fit_obj)
})
output$text_diagnostics_table <- shiny::renderPrint({
shiny::req(vals$model_fit_obj)
tryCatch({
if (exists("diagnose_fit", asNamespace("bayescores"))) {
print(bayescores::diagnose_fit(vals$model_fit_obj$stan_fit))
} else {
print(rstan::monitor(vals$model_fit_obj$stan_fit, print = FALSE))
}
}, error = function(e) {
print(rstan::check_hmc_diagnostics(vals$model_fit_obj$stan_fit))
})
})
output$plot_diagnostics <- shiny::renderPlot({
shiny::req(vals$model_fit_obj)
tryCatch({
bayescores::model_diagnostics(vals$model_fit_obj)
}, error = function(e) {
plot(vals$model_fit_obj$stan_fit, pars = c("lp__"))
})
})
output$repro_code <- shiny::renderText({
shiny::req(vals$code_text)
vals$code_text
})
output$dl_model_rds <- shiny::downloadHandler(
filename = function() "bayesian_model.rds",
content = function(f) saveRDS(vals$model_fit_obj, f)
)
# NEW: CSV Download for Draws
output$dl_draws_csv <- shiny::downloadHandler(
filename = function() "mcmc_draws.csv",
content = function(f) {
shiny::req(vals$model_fit_obj)
# Extract draws (sims)
# Usually rstan fit objects can be coerced to data.frame
draws <- as.data.frame(vals$model_fit_obj$stan_fit)
write.csv(draws, f, row.names = FALSE)
}
)
output$dl_plot_dens <- shiny::downloadHandler(
filename = "densities.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
# Capture the plot object first to avoid auto-printing if any
p <- bayescores::plot_densities(vals$model_fit_obj)
# Add theme and print explicitly
print(p + ggplot2::theme(aspect.ratio = 1))
dev.off()
}
)
output$dl_plot_corr <- shiny::downloadHandler(
filename = "correlated.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
print(bayescores::plot_correlated_densities(vals$model_fit_obj) + ggplot2::theme(aspect.ratio = 1))
dev.off()
}
)
output$dl_plot_fit <- shiny::downloadHandler(
filename = "fit.pdf",
content = function(f) {
pdf(f, width = 10, height = 8)
graphics::par(pty = "s")
plot(vals$model_fit_obj)
dev.off()
}
)
output$dl_plot_diag <- shiny::downloadHandler(
filename = "diagnostics.pdf",
content = function(f) {
shiny::req(vals$model_fit_obj)
pdf(f, width = 10, height = 8)
tryCatch({
bayescores::model_diagnostics(vals$model_fit_obj)
}, error = function(e) {
plot(vals$model_fit_obj$stan_fit, pars = c("lp__"))
})
dev.off()
}
)
}
shiny::shinyApp(ui, server)
}
km2bayes()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::install()
devtools::install()
system("git push")
# 1. Traer los cambios de GitHub a tu PC
system("git pull")
# 2. (Si no hubo conflictos) Subir tus cambios
system("git push")
# 1. Configura tu email
system('git config --global user.email "carmonab@um.es"')
# 2. Configura tu nombre
system('git config --global user.name "Alberto Carmona Bayonas"')
system("git pull")
# 1. Añadir todos los archivos modificados al "paquete" de envío
system("git add .")
# 2. Confirmar los cambios (crear el "paquete")
# Ahora funcionará porque ya configuraste tu email y nombre en el paso anterior
system('git commit -m "Actualizacion completa km2bayes"')
# 3. Forzar la subida (Opción Nuclear)
# El "-f" le dice a GitHub: "No me importa lo que tengas tú, quédate con lo mío"
system("git push -f origin main")
devtools::install_github("albertocarm/bayescores", force = TRUE)
devtools::install_github("albertocarm/bystools")
km2bayes()
library(bystools)
km2bayes()
